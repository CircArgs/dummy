import os
import paramiko
import socket
import threading

# SSH Server Host Keys
HOST_KEY = paramiko.RSAKey.generate(2048)

# Directory to serve for SFTP operations (restricted to /workspace)
BASE_DIR = "/workspace"
os.makedirs(BASE_DIR, exist_ok=True)

# SSH Server Configuration
HOST = "0.0.0.0"
PORT = 2222

# Custom SFTP Server Interface
class SimpleSFTPServer(paramiko.SFTPServerInterface):
    def __init__(self, server, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.server = server

    def _realpath(self, path):
        """Convert relative paths to absolute paths within BASE_DIR."""
        return os.path.abspath(os.path.join(BASE_DIR, os.path.normpath(path.lstrip("/"))))

    def list_folder(self, path):
        real_path = self._realpath(path)
        if not os.path.exists(real_path):
            raise IOError("No such directory")
        files = []
        for item in os.listdir(real_path):
            item_path = os.path.join(real_path, item)
            attr = paramiko.SFTPAttributes.from_stat(os.stat(item_path))
            attr.filename = item
            files.append(attr)
        return files

    def open(self, path, flags, attr):
        real_path = self._realpath(path)
        try:
            mode = "r+b" if os.path.exists(real_path) else "w+b"
            if flags & os.O_WRONLY:
                mode = "wb"
            elif flags & os.O_RDONLY:
                mode = "rb"
            return open(real_path, mode)
        except Exception as e:
            raise IOError(f"Failed to open file: {e}")

    def remove(self, path):
        real_path = self._realpath(path)
        if os.path.isfile(real_path):
            os.remove(real_path)
        else:
            raise IOError("Not a valid file")

    def rename(self, oldpath, newpath):
        old_real = self._realpath(oldpath)
        new_real = self._realpath(newpath)
        os.rename(old_real, new_real)

    def mkdir(self, path, attr):
        real_path = self._realpath(path)
        os.makedirs(real_path, exist_ok=True)

    def rmdir(self, path):
        real_path = self._realpath(path)
        os.rmdir(real_path)

# SSH Server Class
class SSHServer(paramiko.ServerInterface):
    def __init__(self):
        self.event = threading.Event()

    def check_auth_none(self, username):
        return paramiko.AUTH_SUCCESSFUL

    def get_allowed_auths(self, username):
        return "none"

    def check_channel_request(self, kind, chanid):
        if kind == "session":
            return paramiko.OPEN_SUCCEEDED
        return paramiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED

    def check_channel_subsystem_request(self, channel, name):
        if name == "sftp":
            transport = paramiko.SFTPServer(channel, SimpleSFTPServer)
            threading.Thread(target=transport.serve_forever).start()
            return True
        return False

# Server Function
def start_server():
    print(f"Starting SSH Server on {HOST}:{PORT}")
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_socket.bind((HOST, PORT))
    server_socket.listen(100)

    while True:
        client, addr = server_socket.accept()
        print(f"Connection from {addr}")
        try:
            transport = paramiko.Transport(client)
            transport.add_server_key(HOST_KEY)
            ssh_server = SSHServer()
            transport.start_server(server=ssh_server)
            channel = transport.accept(20)

            if channel is None:
                continue
            print("SFTP Connection Established")
        except Exception as e:
            print(f"Error: {e}")
        finally:
            client.close()

# Main Entry Point
if __name__ == "__main__":
    try:
        start_server()
    except KeyboardInterrupt:
        print("Stopping SSH Server")
