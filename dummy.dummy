import pytest
from unittest.mock import AsyncMock, patch
from toolhub_client.client import ToolHubClient, Tool

TOOLHUB_SERVER_URL = "http://test.toolhub.com"

@pytest.fixture
def client():
    """Fixture to initialize the ToolHubClient."""
    return ToolHubClient(toolhub_server_uri=TOOLHUB_SERVER_URL)

@pytest.mark.asyncio
async def test_list_tools(client):
    """Test the list_tools method."""
    namespace = "test_namespace"
    tools_mock = ["tool1", "tool2"]

    with patch("httpx.AsyncClient.get", new_callable=AsyncMock) as mock_get:
        # Fix: json method must return the data directly
        mock_get.return_value.json.return_value = tools_mock
        mock_get.return_value.raise_for_status = AsyncMock()

        result = await client.list_tools(namespace)

        mock_get.assert_called_once_with(f"{TOOLHUB_SERVER_URL}/list_tools/{namespace}")
        assert result == tools_mock

@pytest.mark.asyncio
async def test_get_schema(client):
    """Test the get_schema method."""
    tool_name = "test_tool"
    namespace = "test_namespace"
    schema_mock = {"name": tool_name, "description": "A test tool"}

    with patch("httpx.AsyncClient.get", new_callable=AsyncMock) as mock_get:
        # Fix: json method must return the data directly
        mock_get.return_value.json.return_value = schema_mock
        mock_get.return_value.raise_for_status = AsyncMock()

        result = await client.get_schema(tool_name, namespace)

        mock_get.assert_called_once_with(f"{TOOLHUB_SERVER_URL}/tool/{namespace}/{tool_name}")
        assert result == schema_mock

@pytest.mark.asyncio
async def test_invoke(client):
    """Test the invoke method."""
    tool_name = "test_tool"
    namespace = "test_namespace"
    arguments = {"param1": "value1"}
    response_mock = {"result": "success"}

    with patch("httpx.AsyncClient.post", new_callable=AsyncMock) as mock_post:
        # Fix: json method must return the data directly
        mock_post.return_value.json.return_value = response_mock
        mock_post.return_value.raise_for_status = AsyncMock()

        result = await client.invoke(tool_name, arguments, {}, namespace)

        mock_post.assert_called_once_with(
            f"{TOOLHUB_SERVER_URL}/use_tool/{namespace}/{tool_name}",
            json={"arguments": arguments},
        )
        assert result == response_mock

@pytest.mark.asyncio
async def test_get_tool(client):
    """Test the get_tool method."""
    tool_name = "test_tool"
    namespace = "test_namespace"
    schema_mock = {"name": tool_name, "description": "A test tool"}

    with patch("httpx.AsyncClient.get", new_callable=AsyncMock) as mock_get:
        # Fix: json method must return the data directly
        mock_get.return_value.json.return_value = schema_mock
        mock_get.return_value.raise_for_status = AsyncMock()

        tool = await client.get_tool(tool_name, namespace)

        mock_get.assert_called_once_with(f"{TOOLHUB_SERVER_URL}/tool/{namespace}/{tool_name}")
        assert isinstance(tool, Tool)
        assert tool.name == tool_name
        assert tool.description == schema_mock["description"]

@pytest.mark.asyncio
async def test_call(client):
    """Test the call method for invoking a tool."""
    tool_name = "test_tool"
    namespace = "test_namespace"
    arguments = {"param1": "value1"}
    schema_mock = {"name": tool_name, "description": "A test tool"}
    response_mock = {"result": "called successfully"}

    with patch("httpx.AsyncClient.get", new_callable=AsyncMock) as mock_get, \
         patch("httpx.AsyncClient.post", new_callable=AsyncMock) as mock_post:
        # Fix: json method must return the data directly
        mock_get.return_value.json.return_value = schema_mock
        mock_get.return_value.raise_for_status = AsyncMock()

        mock_post.return_value.json.return_value = response_mock
        mock_post.return_value.raise_for_status = AsyncMock()

        tool = await client.get_tool(tool_name, namespace)
        result = await tool(arguments)

        mock_get.assert_called_once_with(f"{TOOLHUB_SERVER_URL}/tool/{namespace}/{tool_name}")
        mock_post.assert_called_once_with(
            f"{TOOLHUB_SERVER_URL}/use_tool/{namespace}/{tool_name}",
            json={"arguments": arguments},
        )
        assert result == response_mock
