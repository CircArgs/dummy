# rsync server
from fastapi import FastAPI, UploadFile, Form, HTTPException
from fastapi.responses import JSONResponse
from typing import Optional
import os
import shutil

app = FastAPI()

# Directory where the server will store files
BASE_DIR = "server_files"

# Ensure the directory exists
os.makedirs(BASE_DIR, exist_ok=True)

@app.post("/update-file/")
async def update_file(file: UploadFile, filepath: Optional[str] = Form(...)):
    """
    Receive file content and save it to the specified filepath.
    """
    if not filepath:
        raise HTTPException(status_code=400, detail="Filepath is required.")
    
    # Create full path
    file_path = os.path.join(BASE_DIR, filepath)
    
    # Ensure directories exist
    os.makedirs(os.path.dirname(file_path), exist_ok=True)
    
    # Write file to the server directory
    with open(file_path, "wb") as buffer:
        shutil.copyfileobj(file.file, buffer)
    
    return JSONResponse(content={"status": "success", "filepath": filepath})

@app.delete("/delete-file/")
async def delete_file(filepath: str = Form(...)):
    """
    Delete a file at the specified filepath.
    """
    file_path = os.path.join(BASE_DIR, filepath)
    
    if os.path.exists(file_path):
        os.remove(file_path)
        return JSONResponse(content={"status": "deleted", "filepath": filepath})
    else:
        raise HTTPException(status_code=404, detail="File not found.")


# rsync client
import os
import time
import requests
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

# Configuration
SERVER_URL = "http://localhost:8000"  # Adjust to match the server's forwarded port
LOCAL_DIR = "local_files"            # Directory to monitor

class FileSyncHandler(FileSystemEventHandler):
    """
    Handles file system changes and syncs them with the server.
    """
    def __init__(self, local_dir, server_url):
        self.local_dir = local_dir
        self.server_url = server_url
    
    def upload_file(self, file_path):
        """
        Upload a file to the server.
        """
        relative_path = os.path.relpath(file_path, self.local_dir)
        with open(file_path, "rb") as file:
            response = requests.post(
                f"{self.server_url}/update-file/",
                data={"filepath": relative_path},
                files={"file": file}
            )
            print(f"Uploaded: {relative_path} - {response.status_code}")
    
    def delete_file(self, file_path):
        """
        Inform the server to delete a file.
        """
        relative_path = os.path.relpath(file_path, self.local_dir)
        response = requests.delete(
            f"{self.server_url}/delete-file/",
            data={"filepath": relative_path}
        )
        print(f"Deleted: {relative_path} - {response.status_code}")

    def on_created(self, event):
        if not event.is_directory:
            print(f"File created: {event.src_path}")
            self.upload_file(event.src_path)

    def on_modified(self, event):
        if not event.is_directory:
            print(f"File modified: {event.src_path}")
            self.upload_file(event.src_path)
    
    def on_deleted(self, event):
        if not event.is_directory:
            print(f"File deleted: {event.src_path}")
            self.delete_file(event.src_path)

def main():
    # Ensure the directory exists
    os.makedirs(LOCAL_DIR, exist_ok=True)
    
    event_handler = FileSyncHandler(LOCAL_DIR, SERVER_URL)
    observer = Observer()
    observer.schedule(event_handler, LOCAL_DIR, recursive=True)
    
    print(f"Monitoring directory: {LOCAL_DIR}")
    try:
        observer.start()
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()

if __name__ == "__main__":
    main()



# Dev creation server

from fastapi import FastAPI, HTTPException
from kubernetes import client, config
import os
import yaml
import copy

# FastAPI app
app = FastAPI(title="Dev Creation Server", version="1.0")

# Kubernetes configuration: load in-cluster or local config
try:
    config.load_incluster_config()  # Use this if running inside Kubernetes
except:
    config.load_kube_config()  # Use this for local testing

# Kubernetes CoreV1 API client
k8s_client = client.CoreV1Api()

# Path to the pod template file mounted from ConfigMap
POD_TEMPLATE_FILE = "/app/templates/dev-pod-template.yaml"

# Namespace for pod creation (from environment variables or fallback to 'default')
NAMESPACE = os.getenv("NAMESPACE", "default")

# Read the pod template file into memory at startup
try:
    with open(POD_TEMPLATE_FILE, "r") as f:
        BASE_POD_TEMPLATE = yaml.safe_load(f)
except FileNotFoundError:
    raise FileNotFoundError("Pod template file not found. Ensure the ConfigMap is correctly mounted.")


@app.post("/create-pod/{name}", summary="Create a pod using a template and dynamic name")
async def create_pod(name: str):
    """
    Create a new pod in Kubernetes using a pre-rendered template from a ConfigMap.
    Replaces the 'NAME' placeholder in the pod name with the provided 'name'.
    Adds a label 'created-by=dev-creation-server' to ensure the pods can be identified.
    """
    # Copy the base pod template
    pod_manifest = copy.deepcopy(BASE_POD_TEMPLATE)

    # Replace placeholder in the pod name
    if "metadata" not in pod_manifest or "name" not in pod_manifest["metadata"]:
        raise HTTPException(status_code=500, detail="Invalid pod template: 'metadata.name' is missing.")

    pod_manifest["metadata"]["name"] = pod_manifest["metadata"]["name"].replace("NAME", name)
    pod_manifest["metadata"]["namespace"] = NAMESPACE

    # Add a label to identify pods created by this server
    if "labels" not in pod_manifest["metadata"]:
        pod_manifest["metadata"]["labels"] = {}
    pod_manifest["metadata"]["labels"]["created-by"] = "dev-creation-server"

    try:
        # Create the pod in Kubernetes
        k8s_client.create_namespaced_pod(namespace=NAMESPACE, body=pod_manifest)
        return {
            "status": "Pod created successfully",
            "pod_name": pod_manifest["metadata"]["name"],
            "namespace": NAMESPACE
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/health", summary="Healthcheck endpoint")
async def health_check():
    """
    Healthcheck endpoint to verify the service is running.
    """
    return {"status": "OK", "message": "Service is healthy"}


@app.get("/", summary="Root endpoint")
async def root():
    """
    Root endpoint to verify the API is up.
    """
    return {"message": "Dev Creation Server is running"}

====
apiVersion: v1
kind: ServiceAccount
metadata:
  name: cleanup-serviceaccount
  namespace: kube-system

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: cleanup-pod-role
rules:
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["list", "delete"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: cleanup-pod-rolebinding
subjects:
  - kind: ServiceAccount
    name: cleanup-serviceaccount
    namespace: kube-system
roleRef:
  kind: ClusterRole
  name: cleanup-pod-role
  apiGroup: rbac.authorization.k8s.io
---

apiVersion: batch/v1
kind: CronJob
metadata:
  name: dev-pod-cleanup
  namespace: kube-system  # Global resource can run in kube-system or another central namespace
spec:
  schedule: "0 0 * * *"  # Run every day at midnight
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: cleanup-serviceaccount  # ServiceAccount with required permissions
          containers:
          - name: pod-cleanup
            image: bitnami/kubectl:latest  # Minimal image with curl and kubectl support
            command:
            - /bin/sh
            - -c
            - |
              echo "Starting cleanup of developer pods older than 5 days..."
              
              # Calculate the threshold date (5 days ago)
              THRESHOLD_DATE=$(date -d "5 days ago" --utc +%Y-%m-%dT%H:%M:%SZ)

              # List all pods labeled as developer pods and check their creation timestamps
              kubectl get pods --all-namespaces -l app=tenant-dev-pod -o json | jq -r '
                .items[] | select(.metadata.creationTimestamp < "'$THRESHOLD_DATE'") |
                [.metadata.namespace, .metadata.name] | @tsv
              ' | while read namespace name; do
                  echo "Deleting pod $name in namespace $namespace"
                  kubectl delete pod $name -n $namespace
              done
              
              echo "Cleanup complete."

          restartPolicy: OnFailure
